1. tip文件（term index, 词项索引文件）
    tip文件主要按Field保存term的FST序列化后信息。每个Field最后会生成一个PendingBlock，包含一个FST，可以认为保存了 prefix -> [fp, hasTerms, isFloor]
的映射(虽然PendingBlock是树形的，但是FST中的映射都是平级的)，只是对比hashtable，其可以共用前缀和后缀，节省空间。其中fp指向tim文件中该pendingBlock开始
的FilePointer。后缀信息保存在tim文件中。

2. FST
    a. 为什么要求input有序
        input有序的情况下，当加入一个新key时，可以先求出新加的key和上一次输入的key的公共前缀，然后将将上一次输入的key除公共前缀的部分存入文件中。如果
input无序，首先获取公共前缀比较困难，需要和之前所有的key比较；其次所有的拓扑接口必须保存在内存中，因为无法保证下一个key不会改变之前的拓扑结构，这样对
内存的要求比较高(虽然可以用swap的思路，但这样效率会很低)。

3. FST编码后结构
    后面会解析

@startuml
json ".tip File Layout \n 词典索引文件，用于加速词典查找" as J {
   "Header":[
      {"HeaderMagic\t": "[Int] 0x3fd76c17"},
      {"Codec\t\t": "[String] BlockTreeTermsIndex"},
      {"Version\t\t": "[Int] 0"},
      {"Id\t\t\t": "[16 Bytes] random id"},
      {"SuffixLength\t": "[Byte] 0x0A"},
      {"Suffix\t\t": "[Bytes] Lucene90_0"}
   ],
   "Content":[
      {"FieldA\t": [
         {"FST [Bytes]": [
            {"Prefix1\t": ["fp", "hasTerms\t", "isFloor"]},
            {"Prefix2\t": ["fp", "hasTerms\t", "isFloor"]},
            "..."
         ]}
      ]},
      {"FieldB\t":["..."]},
      "..."
   ],
   "Footer":[
      {"FooterMagic\t": "[Int] 0xc02893e8"},
      {"Zero\t\t\t": "[Int] 0"},
      {"CRC\t\t\t": "[Long] crc"}
   ]
}
@enduml